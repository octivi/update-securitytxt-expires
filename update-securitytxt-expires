#!/usr/bin/env bash
# SPDX-FileCopyrightText: 2025-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# This file is part of the configuration created by Octivi's DevOps team.
# Details at https://octivi.com/devops
#
# This script is part of a GitHub Action available on GitHub Marketplace:
# https://github.com/marketplace/actions/update-securitytxt-expires
#
# Source code repository:https://github.com/octivi/update-securitytxt-expires
#
# Update the Expires field in `security.txt` files to a future date so your published security
# contact metadata stays current.

# Octivi Bash Boilerplate (OBB) Header
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
################################################################################
# Unofficial Bash "Strict Mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
# Define common constants regardless if they are used in the script
__my_name="$(basename "${BASH_SOURCE[0]}")"
readonly __my_name
__my_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __my_dir
__my_path="${__my_dir}/${__my_name}"
# shellcheck disable=SC2034
readonly __my_path
__my_args="$*"
# shellcheck disable=SC2034
readonly __my_args
# Set IFS to just newline and tab
IFS=$'\n\t'
################################################################################

is_github_actions=false
if [[ "${GITHUB_ACTIONS:-}" == "true" ]]; then
  is_github_actions=true
fi

DRY_RUN="${DRY_RUN-}"
VERBOSE="${VERBOSE-}"

usage() {
  cat <<USAGE
Usage: ${__my_name} [--targets targets] [--exclude-paths exclude_paths] [--expires-days expires_days] [--dry-run] [--verbose] [--help|-h]

Options:
  --targets targets               Directories to scan (default: .)
  --exclude-paths exclude_paths   Paths to exclude (default: empty)
  --expires-days expires_days     Non-negative integer, days added to current date (default: 180)
  --dry-run                       Show what would change without modifying files
  --verbose                       Print detailed progress logs
  -h, --help                      Show this help message

For list options, pass a single option-argument and separate items with spaces, commas,
or newlines, for example:
  --targets ". src scripts"
  --exclude-paths "build dist"

Environment:
  DRY_RUN=<any non-empty value>   Enable dry-run mode
  VERBOSE=<any non-empty value>   Enable verbose logs
USAGE
}

emit_group_start() {
  local title="$1"
  if [[ "${is_github_actions}" == true ]]; then
    echo "::group::${title}"
  elif [[ -n "${VERBOSE:-}" ]]; then
    echo "== ${title} =="
  fi
}

emit_group_end() {
  if [[ "${is_github_actions}" == true ]]; then
    echo "::endgroup::"
  fi
}

emit_warning() {
  local message="$1"
  if [[ "${is_github_actions}" == true ]]; then
    echo "::warning::${message}" >&2
  else
    echo "WARNING: ${message}" >&2
  fi
}

append_step_summary() {
  local line="$1"
  if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
    printf '%s\n' "${line}" >> "${GITHUB_STEP_SUMMARY}" || true
  fi
}

log_info() {
  echo "$*"
}

log_verbose() {
  if [[ -n "${VERBOSE:-}" ]]; then
    echo "$*"
  fi
}

die() {
  if [[ "${is_github_actions}" == true ]]; then
    echo "::error::$*" >&2
  else
    echo "ERROR: $*" >&2
  fi
  exit 1
}

append_values() {
  local target_array_name="$1"
  local raw_values="$2"
  local normalized
  local token
  local -a tokens=()
  local -n target_array="${target_array_name}"

  normalized="${raw_values//,/ }"
  normalized="${normalized//$'\r'/ }"
  normalized="${normalized//$'\n'/ }"

  IFS=$' \n\t' read -r -a tokens <<< "${normalized}"
  for token in "${tokens[@]}"; do
    [[ -n "${token//[[:space:]]/}" ]] || continue
    target_array+=("${token}")
  done
}

# Defaults (env overrides with fallbacks)
TARGETS="${TARGETS:-.}"
EXCLUDE_PATHS="${EXCLUDE_PATHS:-}"
EXPIRES_DAYS="${EXPIRES_DAYS:-180}"
CURRENT_DATE="${CURRENT_DATE-}"

# CLI overrides
while (($#)); do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --targets)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --targets"
      TARGETS="$1"
      ;;
    --exclude-paths)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --exclude-paths"
      EXCLUDE_PATHS="$1"
      ;;
    --expires-days)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --expires-days"
      EXPIRES_DAYS="$1"
      ;;
    --dry-run)
      DRY_RUN=1
      ;;
    --verbose)
      VERBOSE=1
      ;;
    --)
      shift
      break
      ;;
    *)
      die "Unknown option: $1"
      ;;
  esac
  shift
done

if (($# > 0)); then
  die "Unexpected arguments: $*"
fi

if ! [[ "${EXPIRES_DAYS}" =~ ^[0-9]+$ ]]; then
  die "EXPIRES_DAYS must be a non-negative integer"
fi

dry_run_enabled=false
verbose_enabled=false
if [[ -n "${DRY_RUN:-}" ]]; then
  dry_run_enabled=true
fi
if [[ -n "${VERBOSE:-}" ]]; then
  verbose_enabled=true
fi

log_info "Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"

if [[ -n "${CURRENT_DATE}" ]]; then
  expires_date="$(date -u -d "${CURRENT_DATE} +${EXPIRES_DAYS} days" +%F)"
else
  expires_date="$(date -u -d "+${EXPIRES_DAYS} days" +%F)"
fi

if [[ -z "${TARGETS//[[:space:]]/}" ]]; then
  emit_warning "No targets provided; nothing to do."
  append_step_summary "### ${__my_name}"
  append_step_summary "- Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"
  append_step_summary "- Result: no targets provided"
  exit 0
fi

declare -a DIRS=()
declare -a EXCLUDES=()
append_values DIRS "${TARGETS}"
append_values EXCLUDES "${EXCLUDE_PATHS}"

shopt -s globstar
valid_dirs=0
candidate_files=0
updated_files=0
emit_group_start "Processing targets"
for dir in "${DIRS[@]}"; do
  [[ -d "${dir}" ]] || continue
  valid_dirs=$((valid_dirs + 1))

  prune_args=()
  for exclude in "${EXCLUDES[@]}"; do
    [[ -n "${exclude}" ]] || continue
    if [[ "${exclude}" == /* ]]; then
      prune_args+=(-path "${exclude}" -prune -o)
    else
      exclude="${exclude#./}"
      prune_args+=(-path "${dir%/}/${exclude}" -prune -o)
    fi
  done

  while IFS= read -r -d '' file; do
    if [[ "$(file --mime-type --brief "${file}")" == text/* ]]; then
      candidate_files=$((candidate_files + 1))
      tmp_file="$(mktemp)"
      sed \
        --regexp-extended \
        -e "s/^Expires: .*/Expires: ${expires_date}T23:59:59Z/" \
        "${file}" > "${tmp_file}"

      if ! cmp -s "${file}" "${tmp_file}"; then
        updated_files=$((updated_files + 1))
        if [[ "${dry_run_enabled}" == true ]]; then
          log_info "[DRY-RUN] Would update ${file}"
        else
          cat "${tmp_file}" > "${file}"
          log_verbose "Updated ${file}"
        fi
      else
        log_verbose "No change: ${file}"
      fi
      rm -f "${tmp_file}"
    fi
  done < <(find "${dir}" "${prune_args[@]}" -type f -path '*/.well-known/security.txt' -print0)
done
emit_group_end

if [[ "${valid_dirs}" -eq 0 ]]; then
  emit_warning "No valid target directories found; nothing to do."
  append_step_summary "### ${__my_name}"
  append_step_summary "- Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"
  append_step_summary "- Result: no valid target directories"
  exit 0
fi

append_step_summary "### ${__my_name}"
append_step_summary "- Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"
append_step_summary "- Candidate files: ${candidate_files}"
append_step_summary "- Files to update: ${updated_files}"
append_step_summary "- Target Expires value: ${expires_date}T23:59:59Z"

if [[ "${dry_run_enabled}" == true ]]; then
  log_info "Dry-run completed. Files to update: ${updated_files}"
else
  log_info "Completed. Updated files: ${updated_files}"
fi
